//! Project context detection and manifest management
//!
//! Provides auto-detection of project type (Rust, Node, Python, etc.)
//! and automatic generation of PROJECT.manifest files.

use std::fs;
use std::path::{Path, PathBuf};

/// Markers to distinguish manifest origin
pub const MANIFEST_MARKER_AUTO: &str = "# AUTO-GENERATED by ARULA Desktop";
pub const MANIFEST_MARKER_AI: &str = "# AI-ENHANCED by ARULA";

/// Detected project type
#[derive(Debug, Clone, PartialEq)]
pub enum ProjectType {
    Rust,
    Node,
    Python,
    Go,
    Unknown,
}

impl ProjectType {
    pub fn as_str(&self) -> &'static str {
        match self {
            ProjectType::Rust => "Rust",
            ProjectType::Node => "Node.js",
            ProjectType::Python => "Python",
            ProjectType::Go => "Go",
            ProjectType::Unknown => "Unknown",
        }
    }
}

/// Result of project auto-detection
#[derive(Debug, Clone)]
pub struct DetectedProject {
    pub project_type: ProjectType,
    pub name: String,
    pub dependencies: Vec<String>,
    pub entry_points: Vec<PathBuf>,
    pub build_command: Option<String>,
    pub test_command: Option<String>,
    pub run_command: Option<String>,
    pub framework: Option<String>,
}

impl Default for DetectedProject {
    fn default() -> Self {
        Self {
            project_type: ProjectType::Unknown,
            name: "unknown".to_string(),
            dependencies: Vec::new(),
            entry_points: Vec::new(),
            build_command: None,
            test_command: None,
            run_command: None,
            framework: None,
        }
    }
}

/// Check if a manifest file was AI-enhanced
pub fn is_ai_enhanced(manifest_path: &Path) -> bool {
    if let Ok(content) = fs::read_to_string(manifest_path) {
        content.starts_with(MANIFEST_MARKER_AI)
    } else {
        false
    }
}

/// Check if a manifest file exists
pub fn manifest_exists(path: &Path) -> bool {
    path.join("PROJECT.manifest").exists()
}

/// Detect project type and extract information from a directory
pub fn detect_project(path: &Path) -> Option<DetectedProject> {
    // Try each project type in order of specificity
    if let Some(project) = parse_cargo_toml(path) {
        return Some(project);
    }
    
    if let Some(project) = parse_package_json(path) {
        return Some(project);
    }
    
    if let Some(project) = detect_python_project(path) {
        return Some(project);
    }
    
    if let Some(project) = detect_go_project(path) {
        return Some(project);
    }
    
    // Return Unknown project if we can at least find some source files
    let has_source_files = path.join("src").exists() 
        || fs::read_dir(path).ok()?.any(|e| {
            e.ok().map(|e| {
                let name = e.file_name().to_string_lossy().to_string();
                name.ends_with(".rs") || name.ends_with(".js") || 
                name.ends_with(".py") || name.ends_with(".go")
            }).unwrap_or(false)
        });
    
    if has_source_files {
        Some(DetectedProject {
            project_type: ProjectType::Unknown,
            name: path.file_name()?.to_string_lossy().to_string(),
            ..Default::default()
        })
    } else {
        None
    }
}

/// Parse Cargo.toml for Rust projects
fn parse_cargo_toml(path: &Path) -> Option<DetectedProject> {
    let cargo_path = path.join("Cargo.toml");
    if !cargo_path.exists() {
        return None;
    }
    
    let content = fs::read_to_string(&cargo_path).ok()?;
    
    // Simple TOML parsing for key fields
    let mut name = path.file_name()?.to_string_lossy().to_string();
    let mut dependencies = Vec::new();
    let mut framework = None;
    
    let mut in_package = false;
    let mut in_dependencies = false;
    
    for line in content.lines() {
        let line = line.trim();
        
        if line.starts_with("[package]") {
            in_package = true;
            in_dependencies = false;
        } else if line.starts_with("[dependencies]") {
            in_package = false;
            in_dependencies = true;
        } else if line.starts_with('[') {
            in_package = false;
            in_dependencies = false;
        } else if in_package && line.starts_with("name") {
            if let Some(val) = extract_toml_string(line) {
                name = val;
            }
        } else if in_dependencies && !line.is_empty() && !line.starts_with('#') {
            // Extract dependency name
            if let Some(dep_name) = line.split('=').next() {
                let dep = dep_name.trim().to_string();
                if !dep.is_empty() {
                    // Detect frameworks
                    match dep.as_str() {
                        "iced" => framework = Some("iced".to_string()),
                        "actix-web" => framework = Some("actix-web".to_string()),
                        "axum" => framework = Some("axum".to_string()),
                        "rocket" => framework = Some("rocket".to_string()),
                        "tauri" => framework = Some("tauri".to_string()),
                        _ => {}
                    }
                    dependencies.push(dep);
                }
            }
        }
    }
    
    // Determine entry points
    let mut entry_points = Vec::new();
    if path.join("src/main.rs").exists() {
        entry_points.push(PathBuf::from("src/main.rs"));
    }
    if path.join("src/lib.rs").exists() {
        entry_points.push(PathBuf::from("src/lib.rs"));
    }
    
    Some(DetectedProject {
        project_type: ProjectType::Rust,
        name: name.clone(),
        dependencies,
        entry_points,
        build_command: Some(format!("cargo build -p {}", name)),
        test_command: Some(format!("cargo test -p {}", name)),
        run_command: Some(format!("cargo run -p {}", name)),
        framework,
    })
}

/// Parse package.json for Node.js projects
fn parse_package_json(path: &Path) -> Option<DetectedProject> {
    let package_path = path.join("package.json");
    if !package_path.exists() {
        return None;
    }
    
    let content = fs::read_to_string(&package_path).ok()?;
    let json: serde_json::Value = serde_json::from_str(&content).ok()?;
    
    let name = json.get("name")
        .and_then(|v| v.as_str())
        .unwrap_or_else(|| path.file_name().unwrap().to_str().unwrap())
        .to_string();
    
    // Extract dependencies
    let mut dependencies = Vec::new();
    let mut framework = None;
    
    if let Some(deps) = json.get("dependencies").and_then(|d| d.as_object()) {
        for (dep, _) in deps {
            // Detect frameworks
            match dep.as_str() {
                "next" => framework = Some("Next.js".to_string()),
                "react" if framework.is_none() => framework = Some("React".to_string()),
                "vue" => framework = Some("Vue.js".to_string()),
                "express" => framework = Some("Express".to_string()),
                "fastify" => framework = Some("Fastify".to_string()),
                _ => {}
            }
            dependencies.push(dep.clone());
        }
    }
    
    // Determine entry points
    let mut entry_points = Vec::new();
    if let Some(main) = json.get("main").and_then(|v| v.as_str()) {
        entry_points.push(PathBuf::from(main));
    }
    if path.join("src/index.js").exists() {
        entry_points.push(PathBuf::from("src/index.js"));
    }
    if path.join("src/index.ts").exists() {
        entry_points.push(PathBuf::from("src/index.ts"));
    }
    
    // Extract scripts
    let scripts = json.get("scripts").and_then(|s| s.as_object());
    let build_command = scripts.and_then(|s| s.get("build")).and_then(|v| v.as_str()).map(|s| format!("npm run build # {}", s));
    let test_command = scripts.and_then(|s| s.get("test")).and_then(|v| v.as_str()).map(|s| format!("npm test # {}", s));
    let run_command = scripts.and_then(|s| s.get("start").or_else(|| s.get("dev"))).and_then(|v| v.as_str()).map(|s| format!("npm start # {}", s));
    
    Some(DetectedProject {
        project_type: ProjectType::Node,
        name,
        dependencies,
        entry_points,
        build_command,
        test_command,
        run_command,
        framework,
    })
}

/// Detect Python project
fn detect_python_project(path: &Path) -> Option<DetectedProject> {
    let has_pyproject = path.join("pyproject.toml").exists();
    let has_setup = path.join("setup.py").exists();
    let has_requirements = path.join("requirements.txt").exists();
    
    if !has_pyproject && !has_setup && !has_requirements {
        return None;
    }
    
    let name = path.file_name()?.to_string_lossy().to_string();
    let mut dependencies = Vec::new();
    let mut framework = None;
    
    // Parse requirements.txt for dependencies
    if has_requirements {
        if let Ok(content) = fs::read_to_string(path.join("requirements.txt")) {
            for line in content.lines() {
                let line = line.trim();
                if !line.is_empty() && !line.starts_with('#') {
                    let dep = line.split(['=', '>', '<', '[', ';']).next().unwrap_or(line).trim().to_string();
                    if !dep.is_empty() {
                        match dep.as_str() {
                            "django" | "Django" => framework = Some("Django".to_string()),
                            "flask" | "Flask" => framework = Some("Flask".to_string()),
                            "fastapi" | "FastAPI" => framework = Some("FastAPI".to_string()),
                            _ => {}
                        }
                        dependencies.push(dep);
                    }
                }
            }
        }
    }
    
    // Find entry points
    let mut entry_points = Vec::new();
    if path.join("main.py").exists() {
        entry_points.push(PathBuf::from("main.py"));
    }
    if path.join("app.py").exists() {
        entry_points.push(PathBuf::from("app.py"));
    }
    if path.join("src/main.py").exists() {
        entry_points.push(PathBuf::from("src/main.py"));
    }
    
    Some(DetectedProject {
        project_type: ProjectType::Python,
        name,
        dependencies,
        entry_points,
        build_command: None,
        test_command: Some("pytest".to_string()),
        run_command: Some("python main.py".to_string()),
        framework,
    })
}

/// Detect Go project
fn detect_go_project(path: &Path) -> Option<DetectedProject> {
    let go_mod = path.join("go.mod");
    if !go_mod.exists() {
        return None;
    }
    
    let content = fs::read_to_string(&go_mod).ok()?;
    let mut name = path.file_name()?.to_string_lossy().to_string();
    let mut dependencies = Vec::new();
    
    for line in content.lines() {
        let line = line.trim();
        if line.starts_with("module ") {
            name = line.strip_prefix("module ")?.trim().to_string();
            // Use just the last part of module path
            if let Some(last) = name.rsplit('/').next() {
                name = last.to_string();
            }
        } else if line.starts_with("require ") || (!line.starts_with("//") && line.contains(" v")) {
            if let Some(dep) = line.split_whitespace().next() {
                if !dep.is_empty() && dep != "require" && dep != "(" && dep != ")" {
                    dependencies.push(dep.to_string());
                }
            }
        }
    }
    
    // Find entry points
    let mut entry_points = Vec::new();
    if path.join("main.go").exists() {
        entry_points.push(PathBuf::from("main.go"));
    }
    if path.join("cmd").exists() {
        entry_points.push(PathBuf::from("cmd/"));
    }
    
    Some(DetectedProject {
        project_type: ProjectType::Go,
        name,
        dependencies,
        entry_points,
        build_command: Some("go build".to_string()),
        test_command: Some("go test ./...".to_string()),
        run_command: Some("go run .".to_string()),
        framework: None,
    })
}

/// Generate auto-manifest content from detected project
pub fn generate_auto_manifest(project: &DetectedProject) -> String {
    let mut output = String::new();
    
    // Header with marker
    output.push_str(MANIFEST_MARKER_AUTO);
    output.push_str("\n# Run \"Initialize with AI\" to enhance this manifest with detailed project understanding\n\n");
    
    output.push_str("PROJECT_MANIFEST v1.0\n\n");
    
    // Metadata
    output.push_str("# METADATA\n");
    output.push_str(&format!("name: {}\n", project.name));
    output.push_str(&format!("type: {}\n", project.project_type.as_str()));
    output.push_str(&format!("language: {}\n", project.project_type.as_str()));
    if let Some(ref fw) = project.framework {
        output.push_str(&format!("framework: {}\n", fw));
    }
    output.push('\n');
    
    // Dependencies (first 15 max)
    if !project.dependencies.is_empty() {
        output.push_str("# DETECTED DEPENDENCIES\n");
        for dep in project.dependencies.iter().take(15) {
            output.push_str(&format!("- {}\n", dep));
        }
        if project.dependencies.len() > 15 {
            output.push_str(&format!("# ... and {} more\n", project.dependencies.len() - 15));
        }
        output.push('\n');
    }
    
    // Entry points
    if !project.entry_points.is_empty() {
        output.push_str("# ENTRY POINTS\n");
        for entry in &project.entry_points {
            output.push_str(&format!("- {}\n", entry.display()));
        }
        output.push('\n');
    }
    
    // Workflow commands
    output.push_str("# WORKFLOW\n");
    if let Some(ref cmd) = project.build_command {
        output.push_str(&format!("build: {}\n", cmd));
    }
    if let Some(ref cmd) = project.test_command {
        output.push_str(&format!("test: {}\n", cmd));
    }
    if let Some(ref cmd) = project.run_command {
        output.push_str(&format!("run: {}\n", cmd));
    }
    
    output
}

/// Extract string value from TOML line like: name = "value"
fn extract_toml_string(line: &str) -> Option<String> {
    let parts: Vec<&str> = line.splitn(2, '=').collect();
    if parts.len() == 2 {
        let value = parts[1].trim();
        // Remove quotes
        let value = value.trim_matches('"').trim_matches('\'');
        Some(value.to_string())
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_extract_toml_string() {
        assert_eq!(extract_toml_string("name = \"my-project\""), Some("my-project".to_string()));
        assert_eq!(extract_toml_string("name = 'single-quoted'"), Some("single-quoted".to_string()));
    }
    
    #[test]
    fn test_project_type_as_str() {
        assert_eq!(ProjectType::Rust.as_str(), "Rust");
        assert_eq!(ProjectType::Node.as_str(), "Node.js");
    }
}
