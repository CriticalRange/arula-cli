//! Modern AI Agent Client that integrates with existing API infrastructure
//!
//! This module provides a high-level agent interface that uses the modern tool calling
//! patterns while integrating with the existing reqwest-based API client.

use crate::api::agent::{AgentOptions, ContentBlock, ToolRegistry};
use crate::api::api::{ApiClient, ChatMessage};
use crate::tools::tools::{create_basic_tool_registry, initialize_mcp_tools};
use crate::utils::config::Config;
use crate::utils::debug::debug_print;
use crate::utils::error_utils::{api_error, stream_error, ErrorContext};
use anyhow::Result;
use futures::Stream;
use serde_json::json;
use std::pin::Pin;
use tokio::sync::mpsc;
use tokio_stream::wrappers::UnboundedReceiverStream;

/// Modern AI Agent Client
pub struct AgentClient {
    api_client: ApiClient,
    tool_registry: ToolRegistry,
    options: AgentOptions,
    config: crate::utils::config::Config,
}

impl Clone for AgentClient {
    fn clone(&self) -> Self {
        // For Clone, we need to create a new registry but Clone is sync
        // So we'll create a minimal registry without MCP tools for cloning
        let mut registry = crate::api::agent::ToolRegistry::new();

        // Register basic tools (non-MCP)
        registry.register(crate::tools::tools::BashTool::new());
        registry.register(crate::tools::tools::FileReadTool::new());
        registry.register(crate::tools::tools::FileEditTool::new());
        registry.register(crate::tools::tools::WriteFileTool::new());
        registry.register(crate::tools::tools::ListDirectoryTool::new());
        registry.register(crate::tools::tools::SearchTool::new());
        registry.register(crate::tools::tools::WebSearchTool::new());
        registry.register(crate::tools::tools::VisioneerTool::new());
        registry.register(crate::tools::tools::QuestionTool::new());

        Self {
            api_client: self.api_client.clone(),
            tool_registry: registry,
            options: self.options.clone(),
            config: self.config.clone(),
        }
    }
}

impl AgentClient {
    /// Create a new agent client with the given configuration
    pub fn new(
        provider: String,
        endpoint: String,
        api_key: String,
        model: String,
        options: AgentOptions,
        config: &crate::utils::config::Config,
    ) -> Self {
        let api_client = ApiClient::new(provider, endpoint, api_key, model);
        let tool_registry = create_basic_tool_registry();

        Self {
            api_client,
            tool_registry,
            options,
            config: config.clone(),
        }
    }

    /// Create a new agent client with a pre-initialized tool registry (shared via Arc)
    pub fn new_with_registry(
        provider: String,
        endpoint: String,
        api_key: String,
        model: String,
        options: AgentOptions,
        config: &crate::utils::config::Config,
        tool_registry: crate::api::agent::ToolRegistry,
    ) -> Self {
        let api_client = ApiClient::new(provider, endpoint, api_key, model);

        Self {
            api_client,
            tool_registry,
            options,
            config: config.clone(),
        }
    }

    /// Create an agent client from existing config
    pub fn from_config(provider: String, endpoint: String, api_key: String, model: String) -> Self {
        let options = AgentOptions::default();
        let config = Config::default(); // Create default config for MCP discovery
        Self::new(provider, endpoint, api_key, model, options, &config)
    }

    /// Check if streaming is enabled in the configuration
    pub fn is_streaming_enabled(&self) -> bool {
        self.config.get_streaming_enabled()
    }

    /// Send a message and get a response (streaming or non-streaming based on options)
    pub async fn query(
        &self,
        message: &str,
        conversation_history: Option<Vec<ChatMessage>>,
    ) -> Result<Pin<Box<dyn Stream<Item = ContentBlock> + Send>>> {
        // Check if streaming is disabled in options
        if !self.options.streaming {
            return self.query_non_streaming(message, conversation_history).await;
        }
        
        // Delegate to the unified streaming method
        self.query_streaming(message, conversation_history).await
    }

    /// Send a message with true SSE streaming and automatic tool execution
    ///
    /// This method provides real-time streaming output while handling tool calls.
    /// Unlike `query()`, this uses true Server-Sent Events streaming for immediate
    /// text output as it's generated by the AI.
    ///
    /// # Arguments
    ///
    /// * `message` - The user's message
    /// * `conversation_history` - Optional conversation history
    ///
    /// # Returns
    ///
    /// A stream of `ContentBlock` items representing text, tool calls, and results.
    pub async fn query_streaming(
        &self,
        message: &str,
        conversation_history: Option<Vec<ChatMessage>>,
    ) -> Result<Pin<Box<dyn Stream<Item = ContentBlock> + Send>>> {
        let (tx, rx) = mpsc::unbounded_channel();
        let api_client = self.api_client.clone();
        let auto_execute_tools = self.options.auto_execute_tools;
        let max_tool_iterations = self.options.max_tool_iterations;
        let config_clone = self.config.clone();

        // Get tools from registry
        let tools = self.tool_registry.get_openai_tools();

        // Build messages
        let messages = self.build_api_messages(message, conversation_history)?;

        tokio::spawn(async move {
            // Re-initialize MCP tools if needed (though get_openai_tools above implies they are loaded)
            // But clone needs re-init if it creates a fresh registry? AgentClient::clone does basic registry.
            // We should use the registry we have.
            // The previous code created a NEW registry and re-initialized.
            // But AgentClient::clone method creates a fresh registry with basic tools only.

            // Ideally we'd pass the full registry.
            // But `StreamWithTools` takes `&ToolRegistry`.
            // We can reconstruct it:
            let mut execution_registry = create_basic_tool_registry();
            if let Err(e) = initialize_mcp_tools(&mut execution_registry, &config_clone).await {
                debug_print(&format!("‚ö†Ô∏è Failed to initialize MCP tools: {}", e));
            }

            use crate::api::stream::{stream_with_tools, StreamEvent};

            let tx_for_callback = tx.clone();
            let callback = move |event: StreamEvent| {
                match event {
                    StreamEvent::Start { .. } => {
                        let _ = tx_for_callback.send(ContentBlock::text(""));
                    }
                    StreamEvent::TextDelta(text) => {
                        let _ = tx_for_callback.send(ContentBlock::text(text));
                    }
                    StreamEvent::ThinkingDelta(text) => {
                        let _ = tx_for_callback.send(ContentBlock::reasoning(text));
                    }
                    StreamEvent::ToolCallStart { .. } => {
                        // Tool calls are sent when complete, not at start
                    }
                    StreamEvent::ToolCallDelta { .. } => {}
                    StreamEvent::ToolCallComplete(tc) => {
                        // Send the tool call so the UI can track tool names
                        let _ = tx_for_callback.send(ContentBlock::tool_call(
                            tc.id.clone(),
                            tc.function.name.clone(),
                            tc.function.arguments.clone(),
                        ));
                    }
                    StreamEvent::ToolResult {
                        tool_call_id,
                        result,
                    } => {
                        let _ =
                            tx_for_callback.send(ContentBlock::tool_result(tool_call_id, result));
                    }
                    StreamEvent::Error(e) => {
                        let _ = tx_for_callback.send(ContentBlock::error(e));
                    }
                    StreamEvent::BashOutputLine {
                        tool_call_id,
                        line,
                        is_stderr,
                    } => {
                        let _ = tx_for_callback.send(ContentBlock::BashOutputLine {
                            tool_call_id,
                            line,
                            is_stderr,
                        });
                    }
                    _ => {}
                }
            };

            // We need to modify `stream_with_tools` to emit ToolResult events!
            // But first sticking to `query_streaming` replacement.

            let result = stream_with_tools(
                &api_client,
                messages,
                &tools,
                &execution_registry,
                auto_execute_tools,
                max_tool_iterations,
                callback,
            )
            .await;

            if let Err(e) = result {
                let error_context =
                    ErrorContext::new("Process streaming request").with_anyhow_error(&e);
                let error_msg = stream_error(error_context);
                let _ = tx.send(ContentBlock::error(error_msg));
            }
        });

        Ok(Box::pin(UnboundedReceiverStream::new(rx)))
    }

    /// Send a message with non-streaming mode (waits for complete response)
    ///
    /// This method waits for the complete API response before returning it.
    /// Useful for environments with limited terminal capabilities or when
    /// a complete response is preferred over streaming updates.
    ///
    /// # Arguments
    ///
    /// * `message` - The user's message
    /// * `conversation_history` - Optional conversation history
    ///
    /// # Returns
    ///
    /// A stream of `ContentBlock` items (sent as batch when complete)
    pub async fn query_non_streaming(
        &self,
        message: &str,
        conversation_history: Option<Vec<ChatMessage>>,
    ) -> Result<Pin<Box<dyn Stream<Item = ContentBlock> + Send>>> {
        let (tx, rx) = mpsc::unbounded_channel();
        let api_client = self.api_client.clone();
        let auto_execute_tools = self.options.auto_execute_tools;
        let max_tool_iterations = self.options.max_tool_iterations;
        let debug = self.options.debug;
        let config_clone = self.config.clone();
        let tx_clone = tx.clone();

        // Get tools from registry
        let tools = self.tool_registry.get_openai_tools();

        // Build messages
        let messages = self.build_api_messages(message, conversation_history)?;

        tokio::spawn(async move {
            // Create tool registry for execution
            let mut execution_registry = create_basic_tool_registry();
            if let Err(e) = initialize_mcp_tools(&mut execution_registry, &config_clone).await {
                if debug {
                    debug_print(&format!("‚ö†Ô∏è Failed to initialize MCP tools: {}", e));
                }
            }

            if let Err(e) = Self::handle_non_streaming(
                api_client,
                messages,
                tools,
                tx,
                auto_execute_tools,
                max_tool_iterations,
                debug,
                &execution_registry,
            )
            .await
            {
                let error_context =
                    ErrorContext::new("Complete non-streaming request").with_anyhow_error(&e);
                let error_msg = api_error(error_context);
                let _ = tx_clone.send(ContentBlock::error(error_msg));
            }
        });

        Ok(Box::pin(UnboundedReceiverStream::new(rx)))
    }

    /// Handle non-streaming API calls with tool execution loop
    async fn handle_non_streaming(
        api_client: ApiClient,
        messages: Vec<ChatMessage>,
        tools: Vec<serde_json::Value>,
        tx: mpsc::UnboundedSender<ContentBlock>,
        auto_execute_tools: bool,
        max_tool_iterations: u32,
        debug: bool,
        tool_registry: &crate::api::agent::ToolRegistry,
    ) -> Result<()> {
        let mut current_messages = messages;
        let mut iterations = 0;

        loop {
            if iterations >= max_tool_iterations {
                debug_print("Max tool iterations reached, stopping");
                break;
            }

            if debug {
                debug_print(&format!("Non-streaming iteration {}", iterations + 1));
            }

            // Make non-streaming API call using send_message_with_tools_sync
            let response = api_client
                .send_message_with_tools_sync(&current_messages, &tools)
                .await?;

            // Send reasoning/thinking content if present
            if let Some(ref reasoning) = response.reasoning_content {
                if !reasoning.is_empty() {
                    crate::utils::debug::debug_print(&format!(
                        "üß† Non-streaming: Sending reasoning content: {:?}",
                        reasoning
                    ));
                    let _ = tx.send(ContentBlock::Reasoning {
                        reasoning: reasoning.clone(),
                    });

                    // Check if reasoning content contains XML tool calls (GLM-4.6 style)
                    // If the response has no regular tool_calls, check reasoning for XML format
                    // Skip XML extraction for Anthropic-compatible endpoints (they use structured tool_use)
                    let is_anthropic = api_client.endpoint.contains("/api/anthropic");
                    if response.tool_calls.is_none() && !is_anthropic {
                        use crate::api::xml_toolcall::extract_tool_call_from_xml;
                        if let Some(xml_tool_call) = extract_tool_call_from_xml(reasoning) {
                            // Convert JSON value to ToolCall
                            if let Ok(tool_call) =
                                serde_json::from_value::<crate::api::api::ToolCall>(xml_tool_call)
                            {
                                crate::utils::debug::debug_print(&format!(
                                    "üß† Extracted XML tool call from reasoning: {:?}",
                                    tool_call.function.name
                                ));

                                // Send tool call notification
                                let _ = tx.send(ContentBlock::tool_call(
                                    tool_call.id.clone(),
                                    tool_call.function.name.clone(),
                                    tool_call.function.arguments.clone(),
                                ));

                                // Add to current_messages as if it was a regular tool call
                                current_messages.push(crate::api::api::ChatMessage {
                                    role: "assistant".to_string(),
                                    content: None,
                                    tool_calls: Some(vec![tool_call.clone()]),
                                    tool_call_id: None,
                                    tool_name: None,
                                });

                                // Execute the tool
                                let args: serde_json::Value =
                                    serde_json::from_str(&tool_call.function.arguments)
                                        .unwrap_or(serde_json::json!({}));

                                let tool_result = tool_registry
                                    .execute_tool(&tool_call.function.name, args.clone())
                                    .await;

                                let result_content = match tool_result {
                                    Some(result) => {
                                        // Send tool result
                                        let _ = tx.send(ContentBlock::tool_result(
                                            tool_call.id.clone(),
                                            result.clone(),
                                        ));

                                        // Format for message history
                                        if result.success {
                                            result.data.to_string()
                                        } else {
                                            format!("Error: {}", result.error.unwrap_or_default())
                                        }
                                    }
                                    None => {
                                        let error_msg =
                                            format!("Tool not found: {}", tool_call.function.name);
                                        let _ = tx.send(ContentBlock::tool_result(
                                            tool_call.id.clone(),
                                            crate::api::agent::ToolResult::error(error_msg.clone()),
                                        ));
                                        error_msg
                                    }
                                };

                                // Add tool result to messages
                                current_messages.push(crate::api::api::ChatMessage {
                                    role: "tool".to_string(),
                                    content: Some(result_content),
                                    tool_calls: None,
                                    tool_call_id: Some(tool_call.id.clone()),
                                    tool_name: Some(tool_call.function.name.clone()),
                                });

                                // Continue the loop for another iteration
                                iterations += 1;
                                continue;
                            }
                        }
                    }
                } else {
                    crate::utils::debug::debug_print(
                        "üß† Non-streaming: Reasoning content is empty",
                    );
                }
            } else {
                crate::utils::debug::debug_print(
                    "üß† Non-streaming: No reasoning content in response",
                );
            }

            // Send the complete text response
            if !response.response.is_empty() {
                // Check if regular content contains XML tool calls (GLM-4.6 sometimes puts them here)
                // Only check if there are no explicit tool_calls in the response
                // Skip XML extraction for Anthropic-compatible endpoints (they use structured tool_use)
                let is_anthropic = api_client.endpoint.contains("/api/anthropic");
                if response.tool_calls.is_none()
                    && response.response.contains("<arg_key>")
                    && !is_anthropic
                {
                    use crate::api::xml_toolcall::extract_tool_call_from_xml;
                    if let Some(xml_tool_call) = extract_tool_call_from_xml(&response.response) {
                        if let Ok(tool_call) =
                            serde_json::from_value::<crate::api::api::ToolCall>(xml_tool_call)
                        {
                            crate::utils::debug::debug_print(&format!(
                                "üß† Extracted XML tool call from regular content: {:?}",
                                tool_call.function.name
                            ));

                            // Send tool call notification
                            let _ = tx.send(ContentBlock::tool_call(
                                tool_call.id.clone(),
                                tool_call.function.name.clone(),
                                tool_call.function.arguments.clone(),
                            ));

                            // Add to current_messages as if it was a regular tool call
                            current_messages.push(crate::api::api::ChatMessage {
                                role: "assistant".to_string(),
                                content: None,
                                tool_calls: Some(vec![tool_call.clone()]),
                                tool_call_id: None,
                                tool_name: None,
                            });

                            // Execute the tool
                            let args: serde_json::Value =
                                serde_json::from_str(&tool_call.function.arguments)
                                    .unwrap_or(serde_json::json!({}));

                            let tool_result = tool_registry
                                .execute_tool(&tool_call.function.name, args.clone())
                                .await;

                            let result_content = match tool_result {
                                Some(result) => {
                                    // Send tool result
                                    let _ = tx.send(ContentBlock::tool_result(
                                        tool_call.id.clone(),
                                        result.clone(),
                                    ));

                                    // Format for message history
                                    if result.success {
                                        result.data.to_string()
                                    } else {
                                        format!("Error: {}", result.error.unwrap_or_default())
                                    }
                                }
                                None => {
                                    let error_msg =
                                        format!("Tool not found: {}", tool_call.function.name);
                                    let _ = tx.send(ContentBlock::tool_result(
                                        tool_call.id.clone(),
                                        crate::api::agent::ToolResult::error(error_msg.clone()),
                                    ));
                                    error_msg
                                }
                            };

                            // Add tool result to messages
                            current_messages.push(crate::api::api::ChatMessage {
                                role: "tool".to_string(),
                                content: Some(result_content),
                                tool_calls: None,
                                tool_call_id: Some(tool_call.id.clone()),
                                tool_name: Some(tool_call.function.name.clone()),
                            });

                            // Continue the loop for another iteration
                            iterations += 1;
                            continue;
                        }
                    }
                }

                // Filter out tool results that the AI outputs as text
                // Pattern: "Tool <name> returned: {json}"
                let filtered_content = if response.response.contains(" returned: {") {
                    // Remove lines containing tool results
                    response
                        .response
                        .lines()
                        .filter(|line| {
                            !line.trim().starts_with("Tool ") || !line.contains(" returned: ")
                        })
                        .collect::<Vec<_>>()
                        .join("\n")
                } else {
                    response.response.clone()
                };

                // If no XML tool call was found, send the content as normal text (filtered)
                if !filtered_content.trim().is_empty() {
                    let _ = tx.send(ContentBlock::Text {
                        text: filtered_content,
                    });
                }
            }

            // Check for tool calls
            if let Some(ref calls) = response.tool_calls {
                if !calls.is_empty() && auto_execute_tools {
                    // Add assistant message with tool calls
                    current_messages.push(ChatMessage {
                        role: "assistant".to_string(),
                        content: if response.response.is_empty() {
                            None
                        } else {
                            Some(response.response.clone())
                        },
                        tool_calls: Some(calls.clone()),
                        tool_call_id: None,
                        tool_name: None,
                    });

                    // Execute each tool call
                    for tool_call in calls {
                        // Send tool call notification
                        let _ = tx.send(ContentBlock::tool_call(
                            tool_call.id.clone(),
                            tool_call.function.name.clone(),
                            tool_call.function.arguments.clone(),
                        ));

                        // Parse arguments and execute
                        let args: serde_json::Value =
                            serde_json::from_str(&tool_call.function.arguments)
                                .unwrap_or(json!({}));

                        let tool_result = tool_registry
                            .execute_tool(&tool_call.function.name, args.clone())
                            .await;

                        let result_content = match tool_result {
                            Some(result) => {
                                // Send tool result
                                let _ = tx.send(ContentBlock::tool_result(
                                    tool_call.id.clone(),
                                    result.clone(),
                                ));

                                // Format for message history
                                if result.success {
                                    result.data.to_string()
                                } else {
                                    format!("Error: {}", result.error.unwrap_or_default())
                                }
                            }
                            None => {
                                let error_msg =
                                    format!("Tool not found: {}", tool_call.function.name);
                                let _ = tx.send(ContentBlock::tool_result(
                                    tool_call.id.clone(),
                                    crate::api::agent::ToolResult::error(error_msg.clone()),
                                ));
                                error_msg
                            }
                        };

                        // Add tool result to messages
                        current_messages.push(ChatMessage {
                            role: "tool".to_string(),
                            content: Some(result_content),
                            tool_calls: None,
                            tool_call_id: Some(tool_call.id.clone()),
                            tool_name: Some(tool_call.function.name.clone()),
                        });
                    }

                    // Continue the loop for another iteration
                    iterations += 1;
                    continue;
                } else {
                    // Tool calls present but auto-execute disabled
                    for tool_call in calls {
                        let _ = tx.send(ContentBlock::tool_call(
                            tool_call.id.clone(),
                            tool_call.function.name.clone(),
                            tool_call.function.arguments.clone(),
                        ));
                    }
                }
            }

            // No more tool calls, we're done
            break;
        }

        Ok(())
    }

    /// Register additional tools
    pub fn register_tool<T: crate::api::agent::Tool + 'static>(&mut self, tool: T) {
        self.tool_registry.register(tool);
    }

    /// Initialize MCP tools lazily (called when needed)
    async fn ensure_mcp_tools_initialized(&mut self) {
        // Check if MCP tools are already initialized by looking for MCP server tools
        let has_mcp_tools = self
            .tool_registry
            .get_tools()
            .iter()
            .any(|tool| tool.starts_with("__mcp_") || tool.starts_with("mcp_"));

        if !has_mcp_tools {
            if let Err(e) =
                crate::tools::tools::initialize_mcp_tools(&mut self.tool_registry, &self.config)
                    .await
            {
                eprintln!("‚ö†Ô∏è Failed to initialize MCP tools: {}", e);
            }
        }
    }

    /// Get available tools (with lazy MCP initialization)
    pub async fn get_available_tools(&mut self) -> Vec<String> {
        self.ensure_mcp_tools_initialized().await;
        self.tool_registry.get_tools()
    }

    /// Get available tools (sync version without MCP initialization)
    pub fn get_available_tools_sync(&self) -> Vec<String> {
        self.tool_registry.get_tools()
    }

    /// Build API messages from user message and conversation history
    fn build_api_messages(
        &self,
        message: &str,
        conversation_history: Option<Vec<ChatMessage>>,
    ) -> Result<Vec<ChatMessage>> {
        let mut messages = Vec::new();

        // Check if we have conversation history
        if let Some(history) = conversation_history {
            // Check if the first message is a system message
            let has_system_message = history.first().map_or(false, |msg| msg.role == "system");

            // Add system message only if not already in history
            if !has_system_message {
                messages.push(ChatMessage {
                    role: "system".to_string(),
                    content: Some(self.options.system_prompt.clone()),
                    tool_calls: None,
                    tool_call_id: None,
                    tool_name: None,
                });
            }

            // Add all messages from history
            for msg in history {
                if msg.role != "system" || !has_system_message {
                    messages.push(msg);
                }
            }

            // Check if the last message in history is already the current user message
            let history_has_current_message = messages.last().is_some_and(|last| {
                last.role == "user" && last.content.as_deref() == Some(message)
            });

            // Only add current user message if it's not already in history
            if !history_has_current_message {
                messages.push(ChatMessage {
                    role: "user".to_string(),
                    content: Some(message.to_string()),
                    tool_calls: None,
                    tool_call_id: None,
                    tool_name: None,
                });
            }
        } else {
            // No history provided, add system message and user message
            messages.push(ChatMessage {
                role: "system".to_string(),
                content: Some(self.options.system_prompt.clone()),
                tool_calls: None,
                tool_call_id: None,
                tool_name: None,
            });

            messages.push(ChatMessage {
                role: "user".to_string(),
                content: Some(message.to_string()),
                tool_calls: None,
                tool_call_id: None,
                tool_name: None,
            });
        }

        Ok(messages)
    }
}
